# 스마트십 플랫폼 자동 설치기 — 아키텍처 문서

**버전**: 1.0 (1차 — 설치 자동화)  
**대상**: Ubuntu 기반 OS, Java 기반 스마트십 플랫폼  
**목적**: Excel/CSV 기반 입력으로 다수 타깃 호스트에 규칙 기반 설치 수행, 로깅 및 결과 보고서 생성

---

## 1. 개요 및 컨셉

### 1.1 목적

- **입력**: 설치 정보(Excel/CSV) + 타깃 호스트 정보(Excel/CSV)
- **처리**: 정해진 규칙에 따라 각 호스트에 스마트십 플랫폼 설치
- **부가**: 설치 중 발생 문제 자동/반자동 해결, 전체 작업 로깅, 완료 후 결과 보고서 생성
- **확장**: 2차에서 “설치 후 점검” 단계 추가 예정

### 1.2 역할 가정

- **운영자**: Excel/CSV로 설치 정보·호스트 정보를 준비하고, 설치기를 실행
- **설치기(본 시스템)**: 규칙 엔진 + 설치 스크립트/플레이북으로 실제 설치 수행, 로그 수집, 보고서 작성
- **대상**: Ubuntu 서버(들), Java 런타임, 네트워크 접근 가능 환경

### 1.3 동작 방식 요약

```
[설치 정보 CSV/Excel] ──┐
                        ├──► [규칙 엔진] ──► [설치 실행기] ──► [타깃 호스트들]
[타깃 호스트 CSV/Excel] ─┘                        │
                                                  ▼
                        [로깅] ◄──────────────────┘
                          │
                          ▼
                        [작업 결과 보고서]
```

- 설치 정보와 호스트 정보는 **파일**로만 주고받음 (재현성, 감사 추적 용이).
- “정해진 규칙”은 **설치 규칙 정의 파일**(예: YAML/JSON) 또는 **설치 스크립트/플레이북**으로 표현.
- 2차에서 “설치 후 점검”은 동일 파이프라인 뒤에 **점검 단계**를 이어붙이는 형태로 확장.

---

## 2. 입력 사양

### 2.1 설치 정보 (Excel 또는 CSV)

플랫폼/버전, Java 버전, 구성 옵션 등 “무엇을, 어떻게 설치할지”에 대한 정보.

| 구분 | 설명 | 예시 |
|------|------|------|
| 플랫폼 버전 | 스마트십 플랫폼 버전 | 2.0.1 |
| Java 버전 | JDK/JRE 버전 | 17 |
| 설치 경로 | 앱 설치 디렉터리 | /opt/smartship |
| 설정 프로파일 | 환경별 설정 식별자 | prod, staging |
| 기타 옵션 | DB URL, JVM 옵션, 포트 등 | 키-값 형태 |

- **형식**: CSV 또는 Excel (첫 행 헤더, 컬럼명으로 매핑).
- **다중 시트/파일**: 환경별로 시트를 나누거나 파일을 나눌 수 있도록 “프로파일명” 등으로 식별 가능하게 설계 권장.

### 2.2 타깃 호스트 정보 (Excel 또는 CSV)

어디에 설치할지, 어떻게 접속할지에 대한 정보.

| 구분 | 설명 | 예시 |
|------|------|------|
| host_id | 호스트 식별자 | host-01 |
| hostname / ip | 접속 주소 | 192.168.1.10 또는 server01.example.com |
| ssh_port | SSH 포트 | 22 |
| ssh_user | SSH 사용자 | deploy |
| auth_type | 인증 방식 | key / password |
| auth_value | 키 경로 또는 비밀번호 참조 | ~/.ssh/id_rsa 또는 env:SSH_PASS |
| 역할/역할 그룹 | 해당 호스트 역할 (선택) | app, db, batch |

- **형식**: CSV 또는 Excel, 동일하게 헤더 기반.
- **보안**: 비밀번호는 파일에 평문 저장 지양, 환경 변수/시크릿 매니저 참조 등으로 처리하는 규칙을 문서에 명시.

---

## 3. “정해진 규칙” 정의

### 3.1 규칙이 다루는 범위

- **선행 조건**: OS 버전, 디스크 공간, 메모리, 네트워크 포트 가용성 등
- **설치 순서**: Java 설치 → 의존 패키지 → 스마트십 패키지/배포물 → 설정 주입 → 서비스 등록
- **호스트별 차이**: 역할(app/db/batch)에 따라 다른 패키지/설정 적용
- **실패 시 동작**: 재시도 횟수, 스킵 여부, 롤백 여부

### 3.2 규칙 표현 방식 (제안)

- **선언형**: YAML/JSON으로 “단계(step)”와 “조건(condition)” 정의  
  - 예: `steps: [check_disk, install_java, install_platform, configure, register_service]`
- **스크립트/플레이북**: Shell 스크립트 또는 Ansible 플레이북으로 단계 구현, 규칙 파일에서 “어떤 플레이북을 어떤 순서로 실행할지”만 지정
- **1차 권장**: “규칙 파일(YAML) + Shell/Ansible” 조합으로 시작해, 복잡도에 따라 규칙만 확장

### 3.3 규칙 파일 예시 (개념)

```yaml
# install-rules.yaml (개념)
version: "1.0"
pre_checks:
  - name: disk_space
    min_gb: 10
  - name: memory
    min_mb: 2048
  - name: java_not_present_or_version
    expected_version: "17"
steps:
  - id: install_java
    script: scripts/install-java.sh
    args: ["{{ java_version }}"]
  - id: install_platform
    script: scripts/install-smartship.sh
    args: ["{{ platform_version }}", "{{ install_path }}"]
  - id: configure
    template: templates/app.yml.j2
    dest: "{{ install_path }}/config/application.yml"
  - id: register_service
    script: scripts/register-systemd.sh
on_failure:
  retry: 2
  rollback_script: scripts/rollback.sh
```

- 실제 1차에서는 위와 같은 “규칙 구조”만 확정하고, 단계별 스크립트는 스마트십 실제 배포 방식에 맞춰 채우면 됨.

---

## 4. 설치 흐름 (동작 시나리오)

### 4.1 전체 단계

1. **입력 검증**  
   - 설치 정보·호스트 정보 파일 존재 여부, 필수 컬럼 존재, 값 형식(IP, 포트 등) 검증.
2. **규칙 로드**  
   - 현재 실행에 사용할 규칙 파일(또는 프로파일) 로드.
3. **선행 조건 점검 (선택)**  
   - 각 타깃에 대해 디스크/메모리/Java 등 규칙에 정의된 pre_checks 수행.
4. **호스트별 설치 실행**  
   - 호스트 단위로 순차(또는 규칙에 따른 병렬 제한) 실행.  
   - 각 단계: SSH 등으로 원격 실행 → 출력 캡처 → 로그 기록 → 실패 시 규칙에 따른 재시도/스킵/롤백.
5. **로깅**  
   - 단계별 stdout/stderr, 타임스탬프, 호스트 ID, 단계 ID를 파일에 기록.
6. **결과 집계 및 보고서 생성**  
   - 성공/실패/스킵 호스트 수, 단계별 실패 원인, 로그 위치 등을 정리한 보고서 출력.

### 4.2 실행 주체

- **로컬 실행**: 설치기가 설치되는 “운영 PC/점프 서버”에서 SSH로 각 타깃에 접속해 스크립트 실행.
- **에이전트 실행**: Cursor/CI 등에서 “설치기”를 실행하는 에이전트가 위 흐름을 자동으로 수행하고, 문제 발생 시 로그와 규칙을 참고해 해결 시도 또는 보고.

---

## 5. 문제 해결 전략

### 5.1 자동 처리

- **재시도**: 네트워크 일시 오류, 패키지 lock 등에 대해 규칙에 정의된 횟수만큼 재시도.
- **의존성 실패**: Java 설치 실패 시 이후 단계(플랫폼 설치) 스킵하고 해당 호스트를 “실패”로 기록.
- **명확한 오류 메시지**: 스크립트는 exit code와 stderr에 “오류 코드” 또는 “키워드”를 남겨, 규칙/스크립트에서 “이 메시지면 이렇게 처리” 매핑 가능하도록 설계.

### 5.2 반자동/수동 지원

- **로그 위치 고정**: 호스트별·실행 ID별 로그 디렉터리를 보고서에 명시해, 운영자가 바로 열어볼 수 있게 함.
- **실패 시 중단 옵션**: “첫 실패 시 전체 중단” vs “모든 호스트 시도 후 보고서로 한 번에 확인” 선택 가능하게.
- **재실행**: 실패한 호스트만 다시 실행할 수 있도록 “실패 호스트 목록”을 출력하거나, 해당 목록을 입력으로 받는 모드 지원 (2차에서 구체화 가능).

---

## 6. 로깅 정책

### 6.1 로그 종류

| 로그 | 내용 | 저장 위치 예시 |
|------|------|----------------|
| 실행 로그 | 전체 실행 단계, 시작/종료 시각, 입력 파일 경로 | `logs/run_YYYYMMDD_HHMMSS.log` |
| 호스트별 로그 | 호스트별 각 단계의 stdout/stderr | `logs/runs/YYYYMMDD_HHMMSS/<host_id>.log` |
| 단계별 상세 | 각 step별 명령, exit code, 소요 시간 | 동일 run 디렉터리 내 `steps/<host_id>_<step_id>.log` |

### 6.2 로그 형식

- **공통**: 타임스탬프(ISO8601), 레벨(INFO/WARN/ERROR), run_id, host_id(해당 시), step_id(해당 시), 메시지.
- **에러**: 반드시 exit code, 가능하면 stderr 마지막 N줄 포함해 원인 추적 용이하게.

---

## 7. 작업 결과 보고서

### 7.1 보고서 내용

- **실행 요약**: 실행 ID, 시작/종료 시각, 입력 파일(설치 정보·호스트 정보) 경로.
- **결과 요약**: 전체 호스트 수, 성공/실패/스킵 수.
- **호스트별 결과**: host_id, 성공 여부, 실패 시 실패 단계와 요약 오류 메시지, 해당 로그 파일 경로.
- **조치 제안**: 실패 원인 유형별 “권장 조치”(예: 디스크 부족 → 확보 후 재실행).

### 7.2 출력 형식

- **1차**: 마크다운(.md) 또는 HTML로 생성, 파일로 저장.  
  - 예: `reports/install_report_YYYYMMDD_HHMMSS.md`
- **선택**: 동일 내용을 JSON으로도 출력해 다른 도구(모니터링, 대시보드)에서 활용 가능하게.

---

## 8. 2차 확장: 설치 후 점검

- **위치**: 현재 “설치 실행” 단계 직후에 “점검 단계”를 추가.
- **입력**: 점검 항목 정의(예: 프로세스 기동 여부, HTTP 헬스 체크, 로그 에러 유무).
- **출력**: 설치 보고서에 “점검 결과” 섹션 추가 또는 별도 점검 보고서.
- **아키텍처**: 규칙에 `post_install_checks` 블록을 두고, 점검 스크립트/플레이북을 같은 방식으로 호출하도록 설계하면 1차와 일관성 유지 가능.

---

## 9. 기술 스택 제안

| 구분 | 1차 제안 | 비고 |
|------|----------|------|
| 실행 환경 | Bash + SSH | 단순성, Ubuntu 표준 |
| 원격 실행 | ssh + scp 또는 Ansible | 다수 호스트·복잡도 증가 시 Ansible |
| 입력 파싱 | Python(pandas/openpyxl) 또는 Shell(csv) | Excel은 Python이 유리 |
| 규칙 표현 | YAML | 가독성, 단계 확장 용이 |
| 로깅 | 표준 파일 + 타임스탬프/레벨 | 나중에 syslog/원격 로그 연동 가능 |
| 보고서 | Markdown 템플릿 + 치환 또는 Jinja2 | HTML 옵션은 2차 |

- Java/네트워크 전문성은 “규칙 내용”(포트, 방화벽, JVM 튜닝)과 “설치/점검 스크립트” 작성 시 반영.

---

## 10. 디렉터리 구조 제안

```
onboard-autoinstaller/
├── README.md
├── docs/
│   └── ARCHITECTURE.md          # 본 문서
├── config/
│   └── install-rules.yaml      # 설치 규칙 (예시)
├── input/
│   ├── install-info.csv        # 설치 정보 (샘플)
│   └── target-hosts.csv        # 타깃 호스트 (샘플)
├── scripts/
│   ├── install-java.sh
│   ├── install-smartship.sh
│   ├── register-systemd.sh
│   └── rollback.sh
├── templates/                   # 설정 템플릿 (필요 시)
├── logs/                        # 실행 시 생성
│   └── runs/
└── reports/                     # 보고서 출력
```

- 실제 구현 시 `bin/`(실행 진입점), `lib/`(공통 함수/파서) 등을 추가할 수 있음.

---

## 11. 1차 범위 정리

| 포함 | 비포함 (2차 등) |
|------|------------------|
| CSV/Excel 기반 설치 정보·호스트 정보 입력 | GUI |
| 규칙 기반 설치 단계 실행 | 설치 후 점검 자동화 |
| SSH 기반 원격 설치 | 비-Ubuntu OS |
| 파일 로깅 (실행/호스트/단계별) | 실시간 대시보드 |
| 작업 결과 보고서 (MD/HTML) | 자동 롤백 복구 |
| 실패 시 로그·보고서로 원인 추적 | |

---

이 문서는 “컨셉과 동작 방식, 아키텍처”를 고정하는 용도입니다. 피드백 반영 후 설치 스크립트·규칙·입력 포맷을 구체화하고, 그다음 단계에서 실제 설치 진행을 함께 설계하면 됩니다.
